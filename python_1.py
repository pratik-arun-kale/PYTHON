# -*- coding: utf-8 -*-
"""python 1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sb6wQ34ge96v0jhREqzEJAMMpRbyAWLn
"""

print("helooo world")

"""

```
simple design pattern in python
```

"""

print("--------")
print("````````")
print("|  /\  |")
print("|      |")
print("^______^")

"""variables and data types.

string , integer, float , complex , boolean

string = they are for sentances , words etc

integer = numerical values(not in decimal form)

float = numerical values in decimal form.

complex = complex numbers

boolean = True and false.
"""

name = "Pratik"                               #string
place = "sangli district maharashtra"         
branch ="Mechanical engineering"
university = "IIT GOA"
CGPA = "6.06"
time = 6
# only we can add same type of data type . sring + string. we can add string in int thats why we keep 6 and 6.06 in string form.
print("My name is " +name +"from " +place +".")
print("I have completed my Engineering in " +branch +" in " +university +" and I have A CGPA of " +CGPA +" ")
print("After completing my Engineering I have also done my Python Programming which is of " +str(time) +" months.")    #str()  function used to convert integer to string



"""\n is used to insert a new line."""

phrase ="hi coolers"
print(phrase.upper())      # to make uppercase.
print(phrase.lower())     # to make lowercase
print(phrase.islower())
print(phrase.isupper())   # for cheaking wether it is capital or lowercase
print(len(phrase))   # for calculating length of string
print(phrase.replace("coolers" ,"coder"))    # to replace something in phrase.

num = 6     #assignment
print(5+num)   #addition
print(5-num)  #substraction
pow(5,num)   #  power function

"""taking inputs."""

num1 =input("enter your num :")
num2 =input("enter 2nd number :")
result=float(num1) + float(num2)     #we need to use float or int as bby defualt python understand it as string
print(result)

"""Lists in python"""

players = ["messi" ,"CR7" ,"neymar" ,"iniesta"]
number = [10 ,7 ,11 ,8]
players.insert(4 ,"xavi")    #for inserting at certain position.
number.sort()                #for soting for number incresing order for string alphabetically
players.sort()
print(number)
print(players)
number.reverse()             #for reversing list
print(number)



#creating new list using for 
number = [10 ,7 ,11 ,8]
number_square=[i*i for i in number]
print(number_square)

#touples = they are immutable can't change after initial assognment.
coordinate= (4,5)
#co-ordinate[1]=10 this will not assign 10 at 1 index.
print(coordinate[1])


#touple recognation
name=("pratik")
print(type(name))     #it will print string
name =("pratik" ,)    # by just puting comma
print(type(name))     # it will print touple

#for converting touple into list
my_list = list(coordinate)
print(type(my_list))



#slicing
a=(1,2,3,4,5,6,7)
b=a[1:4]  #assigning values from index 1 to 3 to b
print(b)

c=a[1::2]  # it will start from index 1 to end it will take every 2nd element
print(c)
d=a[::-1]  #it will reverse the touple
print(d)

# touple and list camparision memory and time
import sys
my_list=["pratik",45,434,33222]
my_touple=("pratik",45,434,33222)
print(sys.getsizeof(my_list)," bytes")
print(sys.getsizeof(my_touple)," bytes")
# we can see list take more memory than touple

#time
import timeit
print(timeit.timeit(stmt="[1,2,34,56,777]" ,number =10000000))
print(timeit.timeit(stmt="(1,2,34,56,777)" ,number =10000000))
#we can see list take more time than touple

"""functions.

"""

def intro(name,collage_name):
  print("Hi my name is "+ name+" I am doing my engineering from "+collage_name+" .")
intro("pratik" ,"IIT GOA")
intro("bharath" ,"NIT GOA")

def cube(number):
  return number*number*number
  
print(cube(3))

"""IF STATMENTS."""

#simple calculator program with use of if and else statment
num1 =float(input("enter number 1 :"))
operator =input("enter operator :")
num2=float(input("enter number 2 :"))
if operator =="+" :                # if statment condition always need to be true or false to proceed further.
  print(num1+num2)
elif operator =="-" :
  print(num1-num2)
elif operator =="*" :
  print(num1*num2)
elif operator =="/" :
  print(num1/num2)
else:
  print("invalid input operator")

"""while loops"""

#simple guessing game using while and if else statment.
luckynumber = "9"
guess=""
guess_count=0
guess_limit=3
Guess_over=False
while guess!=luckynumber and not(Guess_over):
  if guess_count<guess_limit:
     guess =input("enter the number :")
     guess_count+=1
  else:
    Guess_over=True
if Guess_over:
  print("you loose")
else:
  print("you won")

#secreat language program.
def translate(phrase):
  transalation=""
  for letter in phrase:
    if letter.lower() in "aeiou":
      if letter.isupper():
        transalation =transalation + "P"
      else:
        transalation =transalation + "p"
    else:
      transalation =transalation + letter
  return transalation
print(translate(input("enter phrase: ")))

"""try and except"""

try:
 # ans =10/0
  num = float(input("enter the num : "))
  print(num)
except ZeroDivisionError as err:
  print("zero division error")
except ValueError:
  print("invalid input")

class student:

  def __init__(self,branch,year) -> None:
      self.branch=branch
      self.year=year


  def confi(self):
    print("hiii I AM engineering student from " , self.branch ,"engineering department in ",self.year ,"year")
student1= student('mechanical' , 4)
student2= student('computer' ,3)
student2.branch="civil"

student1.confi()             #object creation
student2.confi()

#constructor , camparing object , types of variable
class computer:
  colour ="black"     #class variable

  def __init__(self) -> None:
      self.name='AMD'
      self.price=100        #instance variables 

  def campare(self,other):
    if self.price == other.price:
      return True
    else:
      return False 
c1=computer()
c2=computer()
c2.price=200
print(computer.colour) #can acces through class name
if c1.price == c2.price:
  print("price is same")
else:
  print("price is different")

#inner class
class Student:    #outer class
  

  def __init__(self,name,rollno) -> None:
      self.name=name
      self.rollno=rollno 
      self.lap=self.laptop()

  def show(self):
    print(self.name , self.rollno)
    self.lap.show()

  class laptop:     #inner class

    def __init__(self) -> None:
      self.name ='HP'
      self.price =100000
    def show(self):
     print(self.name ,self.price)

          

s1=Student('pratik',9)

s1.show()

#inheritance
class A:
  def feature1(self):
    print("A1 is working")

    
class B(A):                      #inheritance
  def feature2(self):
    print("A2 is working")
a1=B()
a1.feature1()                #we are able to acceses function of superclass

#duck typing
class colab:
  def execute(self):
    print("saves files automatically")
    print("compile code faster")

class notebook:
  def execute(self):
    print("god for large data")
    print("compile code slowly")

class laptop:
  def code(self , ide):
    ide.execute()

ide=notebook()
lap1 =laptop()
lap1.code(ide)

#collections 
#1
#deque is doubly ended queue
# Python code to demonstrate deque
# It provides O(1) time complexity for append and pop operations as compared to list with O(n) time complexity.

from collections import deque
  
# Declaring deque
d =deque()
d.append(1)
d.append(3)
d.appendleft(1)
d.extendleft([4,5,6])
print(d)
d.rotate()
print(d)

# Python program to demonstrate
# defaultdict
#default_factory is a function that provides the default value for the dictionary created. If this parameter is absent then the KeyError is raised.
from collections import defaultdict
  
  
# Defining a dict
d = defaultdict(int)
  
d['a']=1
d['b']=1

print(d['a'])
print(d['c'])

# A Python program to demonstrate working
# of OrderedDict 
# An OrderedDict is also a sub-class of dictionary but unlike dictionary, it remembers the order in which the keys were inserted. 


  
from collections import OrderedDict 
od = OrderedDict() 
od['a'] = 1
od['b'] = 2
od['d'] = 4
od['c'] = 3


for key, value in od.items(): 
    print(key, value)

#A NamedTuple returns a tuple object with names for each position which the ordinary tuples lack

# Python code to demonstrate namedtuple()
    
from collections import namedtuple
    

Student = namedtuple('Student',['name','age','roll_no']) 
S = Student('pratik','22','1906329') 
 #Access using index
print ("The Student age using index is : ",end ="") 
print (S[0]) 
print(S.name)

#A counter is a sub-class of the dictionary. It is used to keep the count of the elements
from collections import Counter 
a ="hhhhhhdddddkkaks"
my_counter = Counter(a)
print(my_counter)
print(my_counter.most_common(1))

#intertools
from itertools import combinations
a=[1,2,3,4,5]
comb=combinations(a,2)
print(list(comb))

from itertools import permutations
a=[1,2,3,4,5]
permutation=permutations(a)
print(list(permutation))

from itertools import accumulate
a=[1,2,3,4,5]
p=accumulate(a)
print(list(p))

from itertools import count
for i in count(10):
  print(i)
  if i>15:
    break

#lamda is small one line function that defined without name
add = lambda x:x+44
print(add(5)) 
def addd(x):             #similar functions.
  return x+44
addd(5)

points=[(3,4),(-4,5),(9,0),(2,4)]
points_sorted=sorted(points)
print(points)
print(points_sorted) #sorted by x value 

#for sorting acc to y value
ypoint_sorted=sorted(points,key=lambda x:x[1])
print(ypoint_sorted)

a=[1,2,3,4,5]
b=map(lambda x:x**2 ,a)
print(list(b))

#similar way
c=[i**2for i in a]
print(c)

import json
person ={"name" :"pratik" , "age":22 ,"collage_name":"IIT GOA"}
person_json=json.dumps(person , indent=4 , sort_keys=True)           # to convert into json data
print(person_json)
person=json.loads(person_json)                                       # to convert json to python data
print(person)

#random numbers
import random
a = random.uniform(0,100)   #it will produce random float
b = random.randint(0,100)   #it will produce random int(upperbound is not included)
c = random.randrange(0,100)   #it will produce random int(upperbound is included)
d = random.normalvariate(0,1)  # i will give random value from standard distrubtion with mean 0 and stadar deviation 1 
print(a)
print(b)
print(c)
print(d)

list1 = [1, 2, 3, 4]          # if the seeding value is 5 then the output of the below program will always be the same.
print(random.choice(list1))

random.seed(1)
  
print(random.random())
print(random.random())

# decorators
# decorators allow us to wrap another function in order to extend the behaviour of the wrapped function, without permanently modifying it.
def function1(func):
  def function2():
    print("start")
    func()
    print("end")
  return function2

@function1            # similar yhing we can do by            function3 = function1(function3)
def function3():
  print("helloooo broooo")

function3()

#genarators 
# they are very memory efficient usful for large dataset

def mygenrator():
  yield 1
  yield 2
  yield 3
g= mygenrator()
value = next(g)
print(value)
value = next(g)
print(value)
value = next(g)
print(value)

import sys
def first1(n):
  nums=[]
  num = 0
  while num<n:
    nums.append(num)
    num +=1
  return nums

def genarotor_num(n):
  num=0
  while num<n:
    yield num
    num +=1

print(first1(10))

print(list(genarotor_num(10)))
print(sys.getsizeof(first1(1000000)))
print(sys.getsizeof(genarotor_num(1000000)))  # we can see the memory difference its huge.

from time import sleep
from threading import *

class hello(Thread):
  def run(self):
    for i in range(5):
      print("helloe")
      sleep(1)

class hey(Thread):
  def run(self):
    for i in range(5):
      print("hey")
      sleep(1)
t1=hello()
t2=hey()

t1.start()
sleep(0.2)
t2.start()

t1.join()   #by using this we can stop main function until threads get completed
t2.join()
print("end")

